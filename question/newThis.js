// 객체 리터럴 방식
/* 
  이 방식은 정말 딱 cat 이라는 객체를 한번 정의해서 만든 것이고, 비슷한 고양이들을  
  새롭게 만들려고 하면 매번 객체를 새롭게 만들어줘야하는 번거로움이 있음
  그래서 생성자 함수를 사용하여 객체를 간편하게 만드려고 하는 것임
  이때 객체 리터럴방식으로 객체를 만들면 프로퍼티마다 , 콤마로 구분하여야 한다.
*/
const cat = {
  name:'고앵',
  age:10
}

// 생성자 함수 방식
/* 
  기존함수에 new 연산자만 붙이면 생성자함수로 동작하게 할 수 있는데, 아래의 함수를
  이용하여 계속해서 내용만 다른 고양이를 만들어내는 것이라 보면됨
  객체의 이름은 계속해서 Cat 이고, Cat을 콘솔에 찍어보면 내용없는 함수 그자체가 
  나옴
  ƒ (name,age){
    this.bark = '야옹';
    this.name = name;
    this.age = age;
  } 이렇게
  저 함수에 이름과 나이를 할당해서 만든 객체를 choco와 nabi 라는 변수에 집어
  넣은것이고, 이렇게하면 함수 하나로 위에서 본 리터럴방식과 다르게 간편하게 객체를
  만들 수 있음

  함수 내에서 this를 찍어보면, 생성한 객체가 나오는데 여기서 곧 새로 만들
  구체적인 인스턴스 자신이 된다. 라는 뜻을 이해할 수 있음
  원래 this가 소환되려면 어떤 객체가 있어야하는데, 원래 함수앞에 . 안찍고 그냥
  호출하면 전역객체가 나옴 하지만, 생성자 함수는 객체를 만들고 있기 때문에 (=이때
  만들어진 객체의 이름을 인스턴스 라고 함) 함수앞에 객체를 만들고 . 찍고 함수 쓰는 
  메소드 형태 (object.method()) 로 보는 것임 그래서 이때의 this는 전역객체가
  아니라 호출하는 본인 인스턴스 객체가 되는 것임 

  생성자함수 방식으로 객체를 만들면, 적용하려는 프로퍼티마다 콤마가 아닌 ; 세미콜론
  으로 구분지어줘야함. 왜냐? 함수니까~

  생성자함수로 안 만들고 그냥 함수로 만들어도 되지 않느냐?
  new 연산자 없이 함수를 만들면, return 문이 현재 존재하지 않기 때문에
  값을 파악할 수 없어서 undefined이 반환됨 
  return문 없이 객체를 반환하려면 new 생성자함수로 만들어야 함
*/
let Cat = function(name,age){
  this.bark = '야옹';
  this.name = name;
  this.age = age;
  console.log('디스가 누구니?',this);
}

let choco = new Cat('초코',7);
let nabi = new Cat('나비',5);


console.log(choco);
console.log(nabi);
